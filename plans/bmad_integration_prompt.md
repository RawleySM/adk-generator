# Implement Bmad_agent, Dev_agent integration, then generate plan for databricks "UC Agents."  Finally, implement

Let's define terms, because we are definitely getting into meta territory for this assignment: We have four different Agents: Dev_agent, Bmad_agent, databricks_rlm_agent and databricks_bmad_agent. The Dev_Agent and Bmad_Agent are the local developers that create a plan and implement the other two agents, who will be deployed in a continous databricks job. The completion promise of this build is fulfilled when databricks_bmad_agent and databricks_rlm_agent are consistently producing fully defined specification plans and implementations for the host of features, patches and bugs captured in Spendmend's backlogged jira task board. To avoid confusion of agent-pairs, lets call the databricks duo the "UC Agents", since together, they represent our agentic development team's interface with the world for which they are seeking to explore: the Databricks Unity Catalog of Databricks git folders and a trove of hospital erp databases stored in delta tables and entrusted to Spendment, an ERP auditing firm. 

Currently, only the databricks_rlm_agent is built, in early prototype form, located in @databricks_rlm_agent/. Its early implementation uses the google-adk python library (adk-python).  This library should guide the build-out of the databricks_bmad_agent, which will tightly couple with the datarbricks_rlm_agent in a google-adk LoopAgent workflow. Here is the current implementaion of the databricks_rlm_agent: 

Let's define "query code" as REPL-style python code that seeks to probe and extract meaning out of a large data source with many files and tables, with answers to multi-hop questions emerging more from a picture painted from the results in stdout, which is passed back to its orginator after safe, pre-validated execution, often with an intermediate consolidation or summariztion step by a "results_processor" of large text chunks.   
The Query code is generated by "databricks_analyst" in an upstream databricks job_A, undergos code and security validation, then is executed in a separate databricks job_b. The query code's stdout is then piped back to a "results_processor" agent that returns the answer to query. This discovery loop is captured in an early prototype form in the agent folder @databricks_rlm_agent/. Task are ingested through this agent, who provides a preliminary "world snapshot" with the neccessary brownfield filepaths, unity catalog schemas, pertinent event history (through error logs), and any other pre-planning data collection that the agent infers from the jira ticket. 
We need to build some structure this ability to probe the Unity Catalog "world"- we need to take intent-capturing process Agile Driven Development and infuse it with the persception of the RLM in databricks_rlm_agent to create a system that can reliably probe, plan, implement, fail, probe again, maybe experiment, and so on. This structure will come from Databricks_bmad_agent, who is to be derived from the successful and proven Bmad-method github repo. 

This is where the other two local agents come in. The Bmad_agent source code in @_bmad/ turns claude into a project strategizing-planning-specification expert. See @_bmad/README.md. I want you to build Dev_Agent, which is to be the execution layer and local coding agent that implements experiments, tests and shippable code based on the documentaton generated by the Bmad_agent. Before we build the more complicated databricks-based system for exploring the Unity Catalog and generating shippable code there, I want you to prove that two agents, one asking guiding questions like the Bmad_Agent, and another agent, in this case YOU, can work together to form a great, detailed plan. 

So your first step is to figure out how to integrate with the ./bmad core. In a previous session, you already figured out how to install it by mocking into the install prompts after some probing of the codebase.  Your integration layer should be un-mocked; you might consider using the claude-agent-sdk, or a headless claude agent. Regardless, it should consist of REAL back and forth interactions with another instance of Claude-code who is wearing whatever "hat" the Bmad core has assigned to him at that planning phase.  Your hat is to represent ME and Spendmend. I've described to you my vision above.  Now I want you to build a plan for it, but first figure out how to work together to do it.  
